//// сортировка пузырьком

// Принцип работы
// 1.	Проходим по массиву n−1 раз, где n — длина массива.
// 2.	На каждой итерации сравниваем текущий элемент с соседним.
// 3.	Если текущий элемент больше следующего (для сортировки по возрастанию), меняем их местами.
// 4.	После первого прохода самый большой элемент оказывается на своём месте (в конце массива).
// 5.	Повторяем процесс для оставшихся элементов.


function bubbleSort(array) {
  debugger;
  const n = array.length;

  for (let i = 0; i < array.length - 1; i++) {
    debugger;
    for (let j = 0; j < array.length - i - 1; j++) {
      //                                       //// в этом цикле мы проходимся по массиву и двигаем 1 цифру вперед, то есть на 1й ит
      debugger; //                             //// меняем 5 и 3, потом 5 и 8 не меняем, потом меняем 8 и 4 и 8 и 2
      //                                       //// итого 8 выползла направо как точно самый большой элемент массива за 1 круг внутр.цикла
      if (array[j] > array[j + 1]) {
        //                                      //// соотв-но это условие: (let j = 0; j < array.length - i - 1; j++) значит, что на сл цикле
        debugger; //                            //// мы не будем пробегать весь массив тк 100% знаем после 1го цикла, что 8 уже крайняя справа, тк самая большая
        // Меняем местами                       //// => j < array.length - i - 1 каждый БОЛЬШОЙ (наружный) круг сокращает массив для внутреннего круга на 1 эл-т
        [array[j], array[j + 1]] = [array[j + 1], array[j]]; //// тк при первой ит-ии на внутреннем круге самый большой элемент уже уполз вправо и идти до него нет смысла
        debugger; //                           //// каждый цикл внутренний 1 эл-т (сам.большой из оставшихся) ползет вправо
      } //                                     //// на сл.цикле сл.элемент попробует доползти максимально правее
      debugger; //                             //// итого когда каждый попробует (усл-е большого круга - перебор всех эл-тов:  for (let i = 0; i < array.length - 1; i++) )
    } //                                       //// итоговая конструкция - цикл в цикле, весь движ - во внутреннем цикле
    debugger;
  }
  console.log(array);
  debugger;
  return array;
}

let a = [5, 3, 8, 4, 2];
//bubbleSort(a);

///// Selection Sort (Сортировка выбором)

// 1.	Разделите массив на две части:
// o	Сортированная (вначале пустая).
// o	Несортированная (изначально весь массив).
// 2.	Найдите минимальный элемент в несортированной части.
// 3.	Поменяйте местами минимальный элемент с первым элементом несортированной части.
// 4.	Увеличьте размер сортированной части на 1.
// 5.	Повторяйте, пока весь массив не станет отсортированным.

const findMin = (arr) => {
  let min = arr[0];
  let ind = 0;
  for (let i = 0; i < arr.length; i++) {
    // делаем отдельную функцию поиска минимального, чтобы не сорить в коде
    if (arr[i] < min) {
      min = arr[i];
      ind = i;
    }
  }
  return { index: ind, minValue: min };
};

const selectionSort = (arr) => {
  let sortedArr = [];
  while (arr.length > 0) { // используй тут именно while, так будет короче и красивее - массив уменьшается с каждым сплайсом, это нужно учитывать
    let { index, minValue } = findMin(arr);
    sortedArr.push(minValue);
    arr.splice(index, 1);
  }
  console.log(sortedArr);
  return sortedArr;
};
// selectionSort(a)


/// Insertion Sort (Сортировка вставками)

// Как работает алгоритм
// 1.	Считаем первый элемент массива отсортированным.
// 2.	Переходим ко второму элементу и сравниваем его с элементами отсортированной части.
// o	Если он меньше, перемещаем его в нужное место.
// 3.	Повторяем шаги для каждого следующего элемента, расширяя отсортированную часть массива.
// 4.	В результате весь массив становится отсортированным.

const insertionSort = (arr) => { //let a = [5, 3, 8, 4, 2]; //                                                                         3я ит// [3, 5, 8, 4, 2];
    for (let i = 1; i < arr.length; i++) { //                                                                                           ||| нач с 8, тк і = 3
      let current = arr[i]; //                  // Текущий элемент, типа отсортированный на 1й ит это 3, тк i начиналось с 1го в цикле  ||| каррент = 4
      let j = i - 1; //                         // индекс предыдущего элемента, на 1й итерации равен 0, сам эл-т на 1й итерации = 5     ||| j = 2
  debugger//                                                                                                                            ||| while (2 >= 0 && 8 > 4) попадаем в цикл   ///(на 2й ит было while (1 >= 0 && 5 > 8)) и не попали
      // Сдвигаем элементы вправо, чтобы найти место для текущего элемента                                                              ||| arr[j + 1] = arr[j] => [3, 5, 8, 8, 2]
      while (j >= 0 && arr[j] > current) {  // тут сравниваем на 1й ит 5 и 3, => ( 0 >= 0 && 5  > 3 ), попадаем в цикл                  |||   j--; => j=1 => (1 >= 0 && 5 > 4) => [3, 5, 5, 8, 2]
        arr[j + 1] = arr[j]; //следующий заменяем предыдущим  (на 1й ит получается  [5, 5, 8, 4, 2])                                    ||| j--; => j=0 => (0 >= 0 && 3 > 5) - 2е усл не вып, т.е в цикл не идем
        j--; // а тут мы ползем сравнивать влево, чтобы не оставить после того, как поменяли, а, если надо, поменять левее              |||
        debugger // но, тк на 1й ит  j--; получается -1, то во 2й раз в цикл мы не заходим, тк  while (j >= 0 && arr[j] > current)      |||  arr[j + 1] = current; => arr[0 + 1] = 4; => [3, 4, 5, 8, 2]
      }          // что логично, ибо двигать левее нулевого элемента не получится                                                       |||
      debugger//                                                                                                                        |||
      // Вставляем текущий элемент в правильное место
      arr[j + 1] = current; // возвращаем тройку на место: arr[j + 1] = arr[0] = 3, см стр где объявлялся каррент
      debugger
    }
    debugger
    console.log(arr);
    return arr;
  };
  
 
///  insertionSort(a); // Вывод: [2, 3, 4, 5, 8]
  